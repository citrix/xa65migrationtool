# Copyright Citrix Systems, Inc.

. .\Version.ps1

Set-Variable -Name DeliveryGroupUid -Scope Script -Value 0
Set-Variable -Name DeliveryGroupName -Scope Script -Value ""
Set-Variable -Name NoPreview -Scope Script -Value $true
Set-Variable -Name AppsImported -Scope Script -Value 0
Set-Variable -Name AppsIgnored -Scope Script -Value 0
Set-Variable -Name ImportStreamedApps -Scope Script -Value $false
Set-Variable -Name ImportDisabledApps -Scope Script -Value $false
Set-Variable -Name MatchFolder -Scope Script -Value $null
Set-Variable -Name MatchWorkerGroup -Scope Script -Value $null
Set-Variable -Name MatchAccount -Scope Script -Value $null
Set-Variable -Name MatchServer -Scope Script -Value $null
Set-Variable -Name NotMatchFolder -Scope Script -Value $null
Set-Variable -Name NotMatchWorkerGroup -Scope Script -Value $null
Set-Variable -Name NotMatchAccount -Scope Script -Value $null
Set-Variable -Name NatMatchServer -Scope Script -Value $null
Set-Variable -Name UserDomains -Scope Script -Value @()
Set-Variable -Name AccessRuleDirect -Scope Script -Value $null
Set-Variable -Name AccessRuleWithAG -Scope Script -Value $null

$ErrorActionPreference = "Stop"

<#
    .Synopsis
        Import XenApp 6.x farm configurations from a XML file.
    .Parameter XmlInputFile
        The name of the XML file that stores the XenApp 6.x farm configuration data.
    .Parameter XsdFile
        The name of the XSD file for validating the XML data. If the file is not
        specified, the file named 'XAFarmData.xsd' located in the script directory
        is used.
    .Parameter DeliveryGroupName
        The default delivery group name for all the applications to be imported. If
        this name is not specified, the default delivery group name is obtained by
        appending the string " - Delivery Group" to the name of the XenApp 6.x
        farm. The global delivery group can be overridden by the <DeliveryGroup>
        element under the <Application> element. The <DeliveryGroup> name is not
        generated by the farm data export script, it must be defined by the user.

        If there are many applications to be put into different delivery groups, you
        may consider to split the input XML file into multiple files according to the
        destination delivery groups and import the applications separately by specifying
        different delivery group names for each run. Thus you can avoid entering the
        <DeliveryGroup> element for large number of applications were you to import all
        applications in just one run.

        The Export-XAFarm command allows you to export applications and store the data
        in separate files, you can specify a different delivery group for each file so
        that the applications are assigned to the specified delivery groups.

        Note: If this parameter is specified on the command line and the named
        delivery group doesn't already exist, it is always created even if there are
        no applications to import into this delivery group. In this case, this script
        creates an empty delivery group.
    .Parameter NoLog
        Do not generate logs if specified. If specified, the LogFile parameter is
        ignored.
    .Parameter NoClobber
        Do not overwrite existing log file. If the LogFile parameter is specified and
        the log file exists, this switch indicates if the file should be overwritten.
        If this switch is specified and the log file exists, an error is returned and
        this script exists.
    .Parameter LogFile
        File for storing the logs. If the file exists and NoClobber is not specified,
        the contents of the file are overwritten. If the file exists and NoClobber is
        specified, an error message is displayed and the script quits. If the log file
        is not specified and NoLog is also not specified, the log is still generated
        and the log file is located under the user's home directory, as specified by
        the $HOME environment variable. The name of the log file is generated using the
        current time stamp: XFarmYYYYMMDDHHmmss-RRRRRR.Log, here YYYY is the year, MM
        is month, DD is day, HH is hour, mm is minute, ss is second, and RRRRRR is a
        six digit random hexdecimal number.
    .Parameter Preview
        Do not execute the actual commands. Just generate the logs. The log file can be
        examined to see what will actually be executed if a real import is performed. If
        logging is disabled, this causes the script to do nothing.
    .Parameter NoDetails
        If specified, the detailed messages about the progress of the script execution
        will not be sent to the console.
    .Parameter MatchFolder
        A regular expression, which specifies that only the applications whose folder
        match the regular expression should be imported. The comparison is case-insensitive.
    .Parameter NotMatchFolder
        A regular expression, which specifies that only the applications whose folder does
        not match the regular expression should be imported. The comparison is
        case-insensitive.
    .Parameter MatchWorkerGroup
        A regular expression, which specifies to import applications that are only
        published to at least one of the worker groups with names match the given regular
        expression. The comparison is case-insensitive.
    .Parameter NotMatchWorkerGroup
        A regular expression, which specifies to import applications that are only
        published to the worker groups that none of the names of the worker groups match
        the given regular expression. The comparison is case-insensitive.
    .Parameter MatchAccount
        A regular expression, which specifies to import only the applications that are
        published with users and at least one of the user names match the given regular
        expression. The comparison is case-insensitive.
    .Parameter NotMatchAccount
        A regular expression, which specifies to import only the applications that are
        published with users and at none of the user names match the given regular
        expression. The comparison is case-insensitive.
    .Parameter MatchServer
        A regular expression, which specifies to import only the applications that are
        published to servers whose names match the given regular expression. The
        comparison is case-insensitive.
    .Parameter NotMatchServer
        A regular expression, which specifies to import only the applications that are
        published to servers whose names do not match the given regular expression. The
        comparison is case-insensitive.
    .Parameter IncludeStreamedApps
        If this switch is specified, applications of type StreamedToClientOrInstalled are
        imported as ServerInstalled applications. The streamed parameters that are not
        applicable are ignored. Other streamed applications that do not have a server
        installed part are still not imported.
    .Parameter IncludeDisabledApps
        If this switch is specifed, disabled applications are imported. Without this switch,
        which is the default, disabled applications are not imported.
    .Parameter SuppressLogo
        Suppress the logo.
    .Description
        Use this cmdlet to import the XenApp 6.x farm configurations that have been
        previously exported to a XML file by the Export-XAFarm cmdlet. This cmdlet
        must be run on a XenDesktop controller and must have the Citrix Broker
        PowerShell snap-in installed on the local server. The user should have
        sufficient privileges to create objects.

        XenDesktop published application executable command line is not allowed to
        contain quotation marks " and the wildcard string "%*". These characters will be
        removed during the import.

        Currently only some of the applications are imported. Streamed applications are
        not imported.

        Application icons are imported if the icon data is embedded in the XML file for
        the application. Icons can also be imported if there is a folder named with the
        name of the input XML file affixed with a string "-icons", and a .txt file named
        with the name of the application being imported is found under this folder. For
        example, if the given XML input file name is FarmData.xml, at the same location a
        folder named as FarmData-icons exists and under this folder there is a file
        notepad.txt, when an application named "notepad" is being imported, the file
        notepad.ext will be used to initialize the application icon. Thus this file must
        contain the encoded binary icon data valid as input for the New-BrokerIcon command.
        For more information about icons, see the help for New-BrokerIcon command.

        For advanced usage of this command, applications can be imported using the folder,
        worker group, and account filters. Using these filters, you can import applications
        to different delivery groups. The filters are .NET regular expressions. For detailed
        information on the regular expression syntax and usage, refer to some of the
        examples below and the Microsoft references on MSDN.

        Positional parameters are not supported. Each parameter must be explicityly specified.
    .Inputs
        A XML data file and optionally other parameters.
    .Outputs
        None
    .Link
        http://msdn.microsoft.com/en-us/library/hs600312(v=vs.110).aspx
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmObjects.XML
        Import applications using the file 'MyFarmObject.XML' in the current directory,
        using the XML schema file XAFarmData.xsd in the current directory. The log file
        is found in the $HOME directory. All the applications are put in the default
        delivery group, which is named using the XenApp 6.x farm's name appended with the
        string " - Delivery Group".
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmObjects.XML -DeliveryGroupName "MyDeliveryGroup"
        Import applications using the file 'MyFarmObjects.XML' file in the current
        directory and specify to put all the applications in the delivery group named
        as "XenApp 6.x Delivery Group". If the delivery group doesn't exist, it is
        created.
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmObjects.XML -Preview -LogFile .\ImportReport.log
        Preview import of the applications specified in the input file 'MyFarmObjects.XML'.
        No applications are imported and the commands that will be used to create the
        actual import are found in the log file 'ImportReport.log' in the current
        directory.
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmApps.XML -MatchFolder ".*/Office Apps/.*"
        Import applications that have the string "Office Apps" in the folder path name.
        Note that this is a regular expression, thus the . is necessary to indicate any
        character. Also, this regular expression matches any folder path that contains
        the string 'Office Apps'. The folder pattern does not contain the leading folder
        root name 'Applications/'.
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmApps.XML -MatchAccount "MyFirm\\Domain Users"
        Import applications that contain 'MyFirm\Domain Users' in the user list of the
        application. The backslash is escaped because it is a regular expression meta
        character. Applications that do not have the user account list specified are not
        imported.
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmApps.XML -MatchWorkerGroup ".*Engineering.*"
        Import applications that are published to worker groups with name containing
        'Engineering'. Applications that are not published to worker groups are not
        imported.
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmApps.XML -MatchFolder "^Applications/b.*" -NotMatchFolder "^Applications/bad apps/.*"
        Import applications that are under the folders with names start with letter 'b' but
        not import the applications under the folder "Applications/bad apps".
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmApps.XML -NotMatchServer ".*Test.*"
        Import applications that are only published to servers whose names don't contain the
        string "Test".
    .Example
        Import-XAFarm -XmlInputFile .\MyFarmApps.XML -IncludeStreamedApps
        Import all applications, including the StreamedToClientOrInstalled applications,
        which have the ServerInstalled component that is actually imported. They are imported
        as regular ServerInstalled applications. The streamed part of these applications are
        ignored. The other streamed applications like StreamedToServer, StreamedToClient, and
        StreamedToClientOrStreamedToServer are still not imported because they don't have a
        ServerInstalled component, which is specified using a CommandLineExecutable and a
        WorkingDirectory.
#>

function Import-XAFarm
{
    [CmdletBinding()]
    param
    (
        [Parameter(Mandatory=$true, ValueFromPipeline=$true, ParameterSetName="Explicit")]
        [string]$XmlInputFile,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [string]$XsdFile,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [string]$DeliveryGroupName,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [switch]$NoLog,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [switch]$NoClobber,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [string]$LogFile,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [switch]$Preview,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [switch]$NoDetails,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [ValidateScript({ Assert-Pattern $_ })]
        [string]$MatchFolder,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [ValidateScript({ Assert-Pattern $_ })]
        [string]$NotMatchFolder,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [ValidateScript({ Assert-Pattern $_ })]
        [string]$MatchWorkerGroup,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [ValidateScript({ Assert-Pattern $_ })]
        [string]$NotMatchWorkerGroup,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [ValidateScript({ Assert-Pattern $_ })]
        [string]$MatchAccount,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [ValidateScript({ Assert-Pattern $_ })]
        [string]$NotMatchAccount,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [ValidateScript({ Assert-Pattern $_ })]
        [string]$MatchServer,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [ValidateScript({ Assert-Pattern $_ })]
        [string]$NotMatchServer,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [switch]$IncludeStreamedApps,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [switch]$IncludeDisabledApps,
        [Parameter(Mandatory=$false, ParameterSetName="Explicit")]
        [switch]$SuppressLogo
    )

    Print-Logo $SuppressLogo

    if ((Get-Module LogUtilities) -eq $null)
    {
        Write-Error "Module LogUtilities.psm1 is not imported, see ReadMe.txt for usage of this script"
        return
    }
    if ((Get-Module XmlUtilities) -eq $null)
    {
        Write-Error "Module XmlUtilities.psm1 is not imported, see ReadMe.txt for usage of this script"
        return
    }

    $Script:ImportStreamedApps = $IncludeStreamedApps
    $Script:ImportDisabledApps = $IncludeDisabledApps
    $Script:MatchFolder = $MatchFolder
    $Script:MatchWorkerGroup = $MatchWorkerGroup
    $Script:MatchAccount = $MatchAccount
    $Script:MatchServer = $MatchServer
    $Script:NotMatchFolder = $NotMatchFolder
    $Script:NotMatchWorkerGroup = $NotMatchWorkerGroup
    $Script:NotMatchAccount = $NotMatchAccount
    $Script:NotMatchServer = $NotMatchServer
    $Script:NoPreview = !$Preview

    $ShowProgress = !$NoDetails
    try
    {
        Start-Logging -NoLog:$Nolog -NoClobber:$NoClobber $LogFile $XmlInputFile -ShowProgress:$ShowProgress
    }
    catch
    {
        Write-Error $_.Exception.Message
        return
    }

    Write-LogFile ([string]::Format('Import-XAFarm Command Line Parameters:'))
    Write-LogFile ([string]::Format('    -XmlInputFile {0}', $XmlInputFile))
    Write-LogFile ([string]::Format('    -XsdFile {0}', $XsdFile))
    Write-LogFile ([string]::Format('    -LogFile {0}', $LogFile))
    Write-LogFile ([string]::Format('    -DeliveryGroupName {0}', $DeliveryGroupName))
    Write-LogFile ([string]::Format('    -Preview = {0}', $Preview))
    Write-LogFile ([string]::Format('    -NoClobber = {0}', $NoClobber))
    Write-LogFile ([string]::Format('    -NoDetails = {0}', $NoDetails))
    Write-LogFile ([string]::Format('    -MatchFolder {0}', $MatchFolder))
    Write-LogFile ([string]::Format('    -NotMatchFolder {0}', $NotMatchFolder))
    Write-LogFile ([string]::Format('    -MatchWorkerGroup {0}', $MatchWorkerGroup))
    Write-LogFile ([string]::Format('    -NotMatchWorkerGroup {0}', $NotMatchWorkerGroup))
    Write-LogFile ([string]::Format('    -MatchAccount {0}', $MatchAccount))
    Write-LogFile ([string]::Format('    -NotMatchAccount {0}', $NotMatchAccount))
    Write-LogFile ([string]::Format('    -MatchServer {0}', $MatchServer))
    Write-LogFile ([string]::Format('    -NotMatchServer {0}', $NotMatchServer))
    Write-LogFile ([string]::Format('    -IncludeStreamedApps = {0}', $IncludeStreamedApps))

    if ([string]::IsNullOrEmpty($XsdFile))
    {
        $XsdFile = ".\XAFarmData.xsd"
    }
    $xmlPath = Resolve-Path $XmlInputFile
    $xsdPath = Resolve-Path $XsdFile

    Assert-XmlInput "XAFarmData.xsd" $xmlPath $xsdPath

    Write-LogFile "Loading Citrix Broker Snap-in" 0 $true 
    $s = (Get-PSSnapin -Registered Citrix.Broker.Admin.V2 -ErrorAction SilentlyContinue)
    if ($s -eq $null)
    {
        Write-Error ([string]::Format("{0}`n{1}",
            "The Citrix Broker PowerShell Snapin is not installed",
            "You must have the Citrix Broker PowerShell Snapin installed to use this script"))
        return
    }
    Write-LogFile "Import-Module (Get-PSSnapin -Registered Citrix.Broker.Admin.V2).ModuleName -Force" 1
    Import-Module (Get-PSSnapin -Registered Citrix.Broker.Admin.V2).ModuleName -Force

    Write-LogFile "Loading Citrix Common Commands Snap-in" 0 $true 
    $s = (Get-PSSnapin -Registered Citrix.Common.Commands -ErrorAction SilentlyContinue)
    if ($s -eq $null)
    {
        Write-Error ([string]::Format("{0}`n{1}",
            "The Citrix Common Commands PowerShell Snapin is not installed",
            "You must have the Citrix Common Commands PowerShell Snapin installed to use this script"))
        return
    }

    if ($Host.Version -eq "2.0")
    {
        $p = Get-PSSnapin Citrix.Common.Commands -ErrorAction SilentlyContinue
        if ($p -eq $null)
        {
            Write-LogFile "Import-Module (Get-PSSnapin -Registered Citrix.Common.Commands).ModuleName -Force" 1
            Import-Module $s.ModuleName -Force -Global
        }
    }
    else
    {
        Write-LogFile "Import-Module (Get-PSSnapin -Registered Citrix.Common.Commands).ModuleName -Force" 1
        Import-Module $s.ModuleName -Force -Global
    }

    Write-LogFile "Reading XML file" 0 $true 
    Write-LogFile ([string]::Format('Get-Content "{0}"', $xmlPath)) 1
    [xml]$farm = Get-Content $xmlPath

    if ($farm.Farm.ConfigurationLogging.LoggingEnabled -eq "true")
    {
        Write-Warning "Configuration logging was enabled in the original XenApp 6.x farm and not imported"
    }

    Write-LogFile "Initializing delivery group for applications" 0 $true 
    $Script:DeliveryGroupName = $farm.Farm.FarmName + " - Delivery Group"
    if (![string]::IsNullOrEmpty($DeliveryGroupName))
    {
        $Script:DeliveryGroupName = $DeliveryGroupName
    }
    if ((Test-BrokerDesktopGroupNameAvailable $Script:DeliveryGroupName).Available)
    {
        New-DesktopGroup $Script:DeliveryGroupName
    }
    else
    {
        $Script:DeliveryGroupUid = (Get-BrokerDesktopGroup $Script:DeliveryGroupName).Uid
    }
    Get-AccessRule $Script:DeliveryGroupName
    Write-LogFile ([string]::Format('Use "{0}" as the delivery group', $Script:DeliveryGroupName)) 1

    $Script:AppsImported = 0
    $Script:AppsIgnored = 0
    $iconDir = Split-Path $xmlPath -Parent
    try
    {
        if ($farm.Farm.Applications -ne $null)
        {
            $farm.Farm.Applications.Application | % { Add-Application $_ $iconDir }
        }
        else
        {
            Write-Warning "No applications found, nothing is imported"
        }
    }
    catch
    {
        Stop-Logging "Application import aborted" $_.Exception.Message
        return
    }

    Set-BrokerSiteMetadata -Name "XAFarmImportToolVersion-378f3aac-51e8-4c75-9208-91fc79bb8c21" -Value $XAMigrationToolVersionNumber

    # Summarize the activities, count number of applications imported, etc.
    Write-LogFile ([string]::Format('{0} applications imported', $Script:AppsImported)) 1 $true
    if ($Script:AppsIgnored -gt 0)
    {
        Write-LogFile ([string]::Format('{0} applications ignored', $Script:AppsIgnored)) 1 $true
    }

    Stop-Logging "Farm import completed"
}

<#
    .Synopsis
        Verify a regular expression pattern
#>

[bool]
function Assert-Pattern
{
    param
    (
        [string]$pattern
    )

    if (![string]::IsNullOrEmpty($pattern) -and $pattern.Trim().Length -gt 0)
    {
        try
        {
            [void]("A random string" -match $pattern)
        }
        catch
        {
            Write-Error ([string]::Format("Regular expression syntax error, {0} is not a valid regular expression`n{1}", $pattern,
                "For more information on how to use regular expressions, see http://msdn.microsoft.com/en-us/library/hs600312"))
            throw
        }
    }
    return $true
}

<#
    .Synopsis
        Generate a new rule name.
    .Description
        Generate a new access policy rule name using the following algorithm.
        1. First append either "Direct" or "WithAG" to the name of the desktop group.
        2. Append a GUID to the root name if the previous name is not available.
        3. Prefix a GUID to the root name if the previous name is still not available.
        4. Trim the name to less than 64 characters. This is required by the
           PowerShell snapin.
#>

function Get-NewRuleName
{
    param
    (
        [string]$rootname,
        [string]$suffix,
        [ScriptBlock]$tester,
        [string]$funcname
    )

    $rulename = $rootname + "_" + $suffix
    if ($rulename.Length -gt 64)
    {
        do
        {
            $rulename = ([Guid]::NewGuid().ToString() + "_" + $rootname).Substring(0, 64)
            Write-LogFile ([string]::Format("{0} -Name '{1}'", $funcname, $rulename)) 2
            $avail = Invoke-Command -ScriptBlock $tester -ArgumentList $rulename
        } while (!$avail)
        return $rulename
    }

    Write-LogFile ([string]::Format("{0} -Name '{1}'", $funcname, $rulename)) 2
    $t = (Test-BrokerAccessPolicyRuleNameAvailable -Name $rulename)
    if ($t.Available)
    {
        return $rulename 
    }

    if ($rootname.Length -gt 29)
    {
        do
        {
            $rulename = ([Guid]::NewGuid().ToString() + "_" + $rootname).Substring(0, 64)
            Write-LogFile ([string]::Format("{0} -Name '{1}'", $funcname, $rulename)) 2
            $avail = Invoke-Command -ScriptBlock $tester -ArgumentList $rulename
        } while (!$avail)
        return $rulename
    }

    do
    {
        $rulename = $rootname + "_" + [Guid]::NewGuid().ToString()
        Write-LogFile ([string]::Format("{0} -Name '{1}'", $funcname, $rulename)) 2
        $avail = Invoke-Command -ScriptBlock $tester -ArgumentList $rulename
    } while (!$avail)

    return $rulename
}

function Test-AccessRuleName
{
    param
    (
        [string]$rulename
    )

    return (Test-BrokerAccessPolicyRuleNameAvailable -Name $rulename).Available
}

function Test-EntitlementRuleName
{
    param
    (
        [string]$rulename
    )

    return (Test-BrokerAppEntitlementPolicyRuleNameAvailable -Name $rulename).Available
}

<#
    .Synopsis
        Create a new delivery group and initialize it so that it can be edited in Studio.
    .Parameter name
        The delivery group name.
#>

function New-DesktopGroup
{
    param
    (
        [string]$name
    )

    Write-LogFile ("Creating shared delivery group " + $name)
    $log = [string]::Format("New-BrokerDesktopGroup '{0}' -DesktopKind Shared -DeliveryType AppsOnly -SessionSupport MultiSession", $name)
    Write-LogFile ($log) 1
    if ($Script:NoPreview)
    {
        $group = (New-BrokerDesktopGroup $name -DesktopKind Shared -DeliveryType AppsOnly -SessionSupport MultiSession)
        $Script:DeliveryGroupUid = $group.Uid
    }

    $rulename = Get-NewRuleName $name "AppEPR" ${function:Test-EntitlementRuleName} "Test-BrokerAppEntitlementPolicyRuleNameAvailable"
    Write-LogFile ([string]::Format("Creating entitlement policy rule '{0}'", $rulename)) 2
    $log = [string]::Format("New-BrokerAppEntitlementPolicyRule {0} {1} {2} {3} -Name '{4}'",
                            "-DesktopGroupUid", $group.Uid,
                            "-Enabled $True",
                            "-IncludedUserFilterEnabled $False",
                            $rulename)
    Write-LogFile ($log) 2
    if ($Script:NoPreview)
    {
        [void](New-BrokerAppEntitlementPolicyRule -DesktopGroupUid $group.Uid `
                                                  -Enabled $True `
                                                  -IncludedUserFilterEnabled $False `
                                                  -Name $rulename)
    }
}

<#
    .Synopsis
        Get the BrokerAccessPolicyRule for ViaAG and NotViaAG. If they don't exist for the
        delivery group, create them.
    .Parameter name
        The delivery group name
#>

function Get-AccessRule
{
    param
    (
        [string]$name
    )

    $ruleObj = Get-BrokerAccessPolicyRule -DesktopGroupName $name -AllowedConnections NotViaAG
    if ($ruleObj -eq $null)
    {
        $rulename = Get-NewRuleName $name "Direct" ${function:Test-AccessRuleName} "Test-BrokerAccessPolicyRuleNameAvailable"
        Write-LogFile ([string]::Format("Creating access policy rule '{0}'", $rulename)) 2
        $log = [string]::Format("New-BrokerAccessPolicyRule {0} {1} {2} {3} {4} {5} {6} {7} {8} -Name '{9}'",
                                "-AllowedConnections 'NotViaAG'",
                                "-AllowedProtocols @('HDX','RDP')",
                                "-AllowRestart $True",
                                "-DesktopGroupUid", $Script:DeliveryGroupUid,
                                "-Enabled $True",
                                "-IncludedSmartAccessFilterEnabled $True",
                                "-IncludedUserFilterEnabled $True",
                                "-IncludedUsers @()",
                                $rulename)
        $Script:AccessRuleDirect = $rulename
        Write-LogFile ($log) 2
        if ($Script:NoPreview)
        {
            [void](New-BrokerAccessPolicyRule -AllowedConnections 'NotViaAG' `
                                              -AllowedProtocols @('HDX','RDP') `
                                              -AllowRestart $True `
                                              -DesktopGroupUid $Script:DeliveryGroupUid `
                                              -Enabled $True `
                                              -IncludedSmartAccessFilterEnabled $True `
                                              -IncludedUserFilterEnabled $True `
                                              -IncludedUsers @() `
                                              -Name $rulename)
        }
    }
    else
    {
        $Script:AccessRuleDirect = $ruleObj.Name
    }

    $ruleObj = Get-BrokerAccessPolicyRule -DesktopGroupName $name -AllowedConnections ViaAG
    if ($ruleObj -eq $null)
    {
        $rulename = Get-NewRuleName $name "WithAG" ${function:Test-AccessRuleName} "Test-BrokerAccessPolicyRuleNameAvailable"
        Write-LogFile ([string]::Format("Creating access policy rule '{0}'", $rulename)) 2
        $log = [string]::Format("New-BrokerAccessPolicyRule {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} -Name '{10}'",
                                "-AllowedConnections 'ViaAG'",
                                "-AllowedProtocols @('HDX','RDP')",
                                "-AllowRestart $True",
                                "-DesktopGroupUid", $Script:DeliveryGroupUid,
                                "-Enabled $True",
                                "-IncludedSmartAccessFilterEnabled $True",
                                "-IncludedSmartAccessTags @()",
                                "-IncludedUserFilterEnabled $True",
                                "-IncludedUsers @()",
                                $rulename)
        $Script:AccessRuleWithAG = $rulename
        Write-LogFile ($log) 2
        if ($Script:NoPreview)
        {
            [void](New-BrokerAccessPolicyRule -AllowedConnections 'ViaAG' `
                                              -AllowedProtocols @('HDX','RDP') `
                                              -AllowRestart $True `
                                              -DesktopGroupUid $Script:DeliveryGroupUid `
                                              -Enabled $True `
                                              -IncludedSmartAccessFilterEnabled $True `
                                              -IncludedSmartAccessTags @() `
                                              -IncludedUserFilterEnabled $True `
                                              -IncludedUsers @() `
                                              -Name $rulename)
        }
    }
    else
    {
        $Script:AccessRuleWithAG = $ruleObj.Name
    }
}

<#
    .Synopsis
        Add "Domain Users" to the IncludedUsers list of an access policy rule.
    .Description
        This function is called only when -Preview is off.
    .Parameter ruleName
        The access policy rule name.
    .Parameter userName
        The domain user name, in "MyCompany\Domain Users" format.
#>

function Add-DomainUsers
{
    param
    (
        [string]$ruleName,
        [string]$userName
    )

    $ruleObj = Get-BrokerAccessPolicyRule -Name $ruleName
    if ($ruleObj -eq $null)
    {
        $log = [string]::Format('INFO: Rule object "{0}" found for delivery group "{1}"', $ruleName, $Script:DeliveryGroupName)
        Write-LogFile $log 2 $false
        return
    }

    if ($ruleObj.IncludedUsers.Name -contains $userName)
    {
        return
    }

    $userList = $ruleObj.IncludedUsers + $userName
    $log = [string]::Format('Set-BrokerAccessPolicyRule -Name "{0}" -IncludedUsers "{1}"...', $rulename, $userName)
    Write-LogFile $log 2
    try
    {
        [void](Set-BrokerAccessPolicyRule -Name $rulename -IncludedUsers $userList)
    }
    catch
    {
        $log = [string]::Format('INFO: "{0}", user "{1}" cannot be added to rule "{2}", ignored', $_.Exception.Message, $userName, $ruleName)
        Write-LogFile ($log) 2 $true
        return
    }

    $log = [string]::Format('Set-BrokerAccessPolicyRule -Name "{0}" -IncludedUserFilterEnabled $true', $ruleName)
    Write-LogFile $log 2
    if ($Script:NoPreview)
    {
        [void](Set-BrokerAccessPolicyrule -Name $rulename -IncludedUserFilterEnabled $true)
    }
}

<#
    .Synopsis
        Add a "Domain Users" account to the delivery group. Then add the specific user name to the
        'limit visibility' list for the application.
    .Parameter account
        The user account to be added.
    .Parameter appObj
        The BrokerApplication object.
#>

function Add-UserAccount
{
    param
    (
        [string]$account,
        [object]$appObj
    )

    $names = $account.Split('\')
    if ($names.Count -ne 2)
    {
        $log = [string]::Format('User name "{0}" is not in domain\user format, not imported', $account)
        Write-LogFile $log 1 $false -isWarning
        return
    }

    $domain = $names[0]
    $user = $names[1]
    if ($Script:UserDomains -notcontains $domain)
    {
        $log = [string]::Format('Adding "{0}\Domain Users" to the user list of delivery group "{1}"',
            $domain, $Script:DeliveryGroupName)
        Write-LogFile $log 1
        if ($Script:NoPreview)
        {
            Add-DomainUsers $Script:AccessRuleDirect ($domain + "\Domain Users")
            Add-DomainUsers $Script:AccessRuleWithAG ($domain + "\Domain Users")
        }
    }

    if ($user -eq "Domain Users")
    {
        return
    }

    Write-LogFile ([string]::Format('Add-BrokerUser -Application $appObj "{0}"', $account)) 2
    if ($Script:NoPreview)
    {
        try
        {
            [void](Add-BrokerUser -Application $appObj $account)
        }
        catch
        {
            $log = [string]::Format('"{0}", User "{1}" cannot be added, ignored', $_.Exception.Message, $account)
            Write-LogFile ($log) 2 $true -isWarning
            return
        }
    }

    Write-LogFile ("Set-BrokerApplication -InputObject $appObj -UserFilterEnabled $true") 2
    if ($Script:NoPreview)
    {
        [void](Set-BrokerApplication -InputObject $appObj -UserFilterEnabled $true)
    }
}

<#
    .Synopsis
        Create a new application using the XML data.
#>

Set-Variable -Name ImaToFma -Option ReadOnly -Scope Script -Value @{
    AddToClientDesktop="ShortcutAddedToDesktop";
    AddToClientStartMenu="ShortcutAddedToStartMenu";
    ClientFolder="ClientFolder";
    CpuPriorityLevel="CpuPriorityLevel";
    Description="Description";
    Enabled="Enabled";
    StartMenuFolder="StartMenuFolder";
    WaitOnPrinterCreation="WaitForPrinterCreation";
    WorkingDirectory="WorkingDirectory";
}

function Add-Application
{
    param
    (
        [object]$xmlObj,
        [string]$iconDir
    )

    [string]$displayName = $xmlObj.DisplayName
    Write-LogFile ([string]::Format('Importing application "{0}"', $displayName)) 0 $true

    [string]$folderPath = $xmlObj.FolderPath
    [string]$pathName = $null
    if (($folderPath -ne $null) -and ($folderPath.Length -gt "APPLICATIONS/".Length))
    {
        foreach ($f in $folderPath.SubString("APPLICATIONS/".Length).Split('/'))
        {
            if ($f.Length -gt 64)
            {
                $log = [string]::Format('Folder "{0}" name length {1} is too long. Folder name must not exceed 64 characters, application "{2}" skipped',
                    $f, $f.Length, $displayName)
                Write-LogFile ($log) 1
                $Script:AppsIgnored++
                return
            }
            $pathName += $f + "\"
        }
    }

    $pathName += $displayName

    if (!(Test-BrokerApplicationNameAvailable $pathName).Available)
    {
        Write-LogFile ([string]::Format('Application "{0}" exists, skipped', $pathName)) 1 -isWarning
        $Script:AppsIgnored++
        return
    }

    $appType = $xmlObj.ApplicationType
    if (($appType -ne "ServerInstalled") -and (($appType -ne "StreamedToClientOrInstalled") -or !$Script:ImportStreamedApps))
    {
        $log = [string]::Format('Unsupported application type {0}, application "{1}" skipped', $appType, $pathName)
        Write-LogFile ($log) 1 $true -isWarning
        $Script:AppsIgnored++
        return
    }

    if (($xmlObj.Enabled -ne "true") -and !$Script:ImportDisabledApps)
    {
        $log = [string]::Format('{0} is disabled, not imported', $pathName)
        Write-LogFile ($log) 1 $true -isWarning
        $Script:AppsIgnored++
        return
    }

    if ($xmlObj.PreLaunch -eq "true")
    {
        $log = [string]::Format('Pre-launch application "{0}" is not supported, skipped', $pathName)
        Write-LogFile ($log) 1 $true -isWarning
        $Script:AppsIgnored++
        return
    }

    if ($appType -eq "StreamedToClientOrInstalled")
    {
        $log = [string]::Format('INFO: Streaming part of "{0}" is not imported', $pathName)
        Write-LogFile ($log) 1 $true
    }

    [string]$executable = $xmlObj.CommandLineExecutable.Trim()
    if ([string]::IsNullOrEmpty($executable))
    {
        $log = [string]::Format('No command line executable specified, application "{0}" skipped', $pathName)
        Write-LogFile ($log) 1 $true -isWarning
        $Script:AppsIgnored++
        return
    }

    $pattern = $Script:MatchFolder
    if ($pattern -ne $null)
    {
        $pattern = $pattern.Trim()
    }
    if (![string]::IsNullOrEmpty($pattern) -and ($folderPath -notmatch $pattern))
    {
        $log = [string]::Format('INFO: "{0}" does not match "{1}", skipped', $folderPath, $pattern)
        Write-LogFile ($log) 1 $true
        $Script:AppsIgnored++
        return
    }

    $pattern = $Script:NotMatchFolder
    if ($pattern -ne $null)
    {
        $pattern = $pattern.Trim()
    }
    if (![string]::IsNullOrEmpty($pattern) -and ($folderPath -match $pattern))
    {
        $log = [string]::Format('INFO: "{0}" match "{1}", skipped', $folderPath, $pattern)
        Write-LogFile ($log) 1 $true
        $Script:AppsIgnored++
        return
    }

    $pattern = $Script:MatchWorkerGroup
    if ($pattern -ne $null)
    {
        $pattern = $pattern.Trim()
    }
    if (![string]::IsNullOrEmpty($pattern))
    {
        if (($xmlObj.WorkerGroups -eq $null) -or !$xmlObj.WorkerGroups.HasChildNodes)
        {
            $log = [string]::Format('INFO: "{0}" has no worker groups and worker group pattern "{1}" is specified, skipped',
                $pathName, $pattern)
            Write-LogFile $log 1 $true
            $Script:AppsIgnored++
            return
        }
        $matches = ($xmlObj.WorkerGroups.WorkerGroup | ? { $_ -match $pattern })
        if ($matches -eq $null)
        {
            $log = [string]::Format('INFO: "{0}" does not have a worker group name matching "{1}", skipped', $pathName, $pattern)
            Write-LogFile ($log) 1 $true
            $Script:AppsIgnored++
            return
        }
    }

    $pattern = $Script:NotMatchWorkerGroup
    if ($pattern -ne $null)
    {
        $pattern = $pattern.Trim()
    }
    if (![string]::IsNullOrEmpty($pattern) -and ($xmlObj.WorkerGroups -ne $null) -and $xmlObj.WorkerGroups.HasChildNodes)
    {
        $matches = ($xmlObj.WorkerGroups.WorkerGroup | ? { $_ -match $pattern })
        if ($matches -ne $null)
        {
            $log = [string]::Format('INFO: "{0}" has a worker group name matching "{1}", skipped', $pathName, $pattern)
            Write-LogFile ($log) 1 $true
            $Script:AppsIgnored++
            return
        }
    }

    $pattern = $Script:MatchAccount
    if ($pattern -ne $null)
    {
        $pattern = $pattern.Trim()
    }
    if (![string]::IsNullOrEmpty($pattern))
    {
        if (($xmlObj.Accounts -eq $null) -or !$xmlObj.Accounts.HasChildNodes)
        {
            $log = [string]::Format('INFO: "{0}" has no user accounts and account pattern "{1}" is specified, skipped', $pathName, $pattern)
            Write-LogFile $log 1 $true
            $Script:AppsIgnored++
            return
        }
        $matches = ($xmlObj.Accounts.Account | ? { $_.AccountDisplayName -match $pattern })
        if ($matches -eq $null)
        {
            $log = [string]::Format('INFO: "{0}" does not have a user account name matching "{1}", skipped', $pathName, $pattern)
            Write-LogFile ($log) 1 $true
            $Script:AppsIgnored++
            return
        }
    }

    $pattern = $Script:NotMatchAccount
    if ($pattern -ne $null)
    {
        $pattern = $pattern.Trim()
    }
    if (![string]::IsNullOrEmpty($pattern) -and ($xmlObj.Accounts -ne $null) -and $xmlObj.Accounts.HasChildNodes)
    {
        $matches = ($xmlObj.Accounts.Account | ? { $_.AccountDisplayName -match $pattern })
        if ($matches -ne $null)
        {
            $log = [string]::Format('INFO: "{0}" have a user account name matching "{1}", skipped', $pathName, $pattern)
            Write-LogFile ($log) 1 $true
            $Script:AppsIgnored++
            return
        }
    }

    $pattern = $Script:MatchServer
    if ($pattern -ne $null)
    {
        $pattern = $pattern.Trim()
    }
    if (![string]::IsNullOrEmpty($pattern))
    {
        if (($xmlObj.Servers -eq $null) -or !$xmlObj.Servers.HasChildNodes)
        {
            $log = [string]::Format('INFO: "{0}" has no servers and server pattern "{1}" is specified, skipped', $pathName, $pattern)
            Write-LogFile $log 1 $true
            $Script:AppsIgnored++
            return
        }
        $matches = ($xmlObj.Servers | ? { $_.Server -match $pattern })
        if ($matches -eq $null)
        {
            $log = [string]::Format('INFO: "{0}" does not have a server name matching "{1}", skipped', $pathName, $pattern)
            Write-LogFile ($log) 1 $true
            $Script:AppsIgnored++
            return
        }
    }

    $pattern = $Script:NotMatchServer
    if ($pattern -ne $null)
    {
        $pattern = $pattern.Trim()
    }
    if (![string]::IsNullOrEmpty($pattern) -and ($xmlObj.Servers -ne $null) -and $xmlObj.Servers.HasChildNodes)
    {
        $matches = ($xmlObj.Servers | ? { $_.Server -match $pattern })
        if ($matches -ne $null)
        {
            $log = [string]::Format('INFO: "{0}" have a server name matching "{1}", skipped', $pathName, $pattern)
            Write-LogFile ($log) 1 $true
            $Script:AppsIgnored++
            return
        }
    }

    [string]$arguments = ""
    if ($executable.StartsWith('"'))
    {
        $matches = [Regex]::Match($executable, '\"([^\"]*)\"(.*)')
    }
    else
    {
        $matches = [Regex]::Match($executable, '(\S+)(.*)')
    }
    if ($matches.Success -and $matches.Groups.Count -ge 3)
    {
        $executable = $matches.Groups[1].Value.Trim()
        $arguments = $matches.Groups[2].Value.Trim()
    }

    $deliveryGroup = $Script:DeliveryGroupName

    [string]$sitePath = $null
    $allFolders = Get-BrokerAdminFolder | Select -ExpandProperty Name
    if (($folderPath -ne $null) -and ($folderPath.ToUpper().StartsWith("APPLICATIONS/")))
    {
        foreach ($f in $folderPath.SubString("APPLICATIONS/".Length).Split('/'))
        {
            $parent = $sitePath
            $sitePath = $sitePath + $f + "\"
            if (!($allFolders -contains $sitePath))
            {
                if ([string]::IsNullOrEmpty($parent))
                {
                    $log = [string]::Format('New-BrokerAdminFolder -FolderName "{0}"', $f)
                    Write-LogFile ($log) 1
                    if ($Script:NoPreview)
                    {
                        [void](New-BrokerAdminFolder -FolderName $f)
                    }
                }
                else
                {
                    $log = [string]::Format('New-BrokerAdminFolder -FolderName "{0}" -ParentFolder "{1}"', $f, $parent)
                    Write-LogFile ($log) 1
                    if ($Script:NoPreview)
                    {
                        [void](New-BrokerAdminFolder -FolderName $f -ParentFolder $parent)
                    }
                }
            }
        }
    }

    Write-LogFile ([string]::Format('Creating new application - "{0}"', $pathName)) 1 $true
    $log = [string]::Format('$appObj = New-BrokerApplication -Name "{0}" -DesktopGroup "{1}" -CommandLineExecutable "{2}"',
        $displayName, $deliveryGroup, $executable)
    if (-not [string]::IsNullOrEmpty($sitePath))
    {
        $log = [string]::Format('{0} -AdminFolder "{1}"', $log, $sitePath)
    }
    Write-LogFile ($log) 2
    if ($Script:NoPreview)
    {
        if ([string]::IsNullOrEmpty($sitePath))
        {
            [void]($appObj = New-BrokerApplication -Name $displayName -DesktopGroup $deliveryGroup -CommandLineExecutable $executable)
        }
        else
        {
            [void]($appObj = New-BrokerApplication -Name $displayName -DesktopGroup $deliveryGroup -CommandLineExecutable $executable -AdminFolder $sitePath)
        }
    }

    if (![string]::IsNullOrEmpty($arguments))
    {
        $log = [string]::Format("Set-BrokerApplication -InputObject $appObj -CommandLineArguments '{0}'", $arguments)
        Write-LogFile ($log) 2
        if ($Script:NoPreview)
        {
            [void](Set-BrokerApplication -InputObject $appObj -CommandLineArguments $arguments)
        }
    }

    $splat = @{}
    $Script:ImaToFma.GetEnumerator() | % {
        $key = $_.Name
        $value = $xmlObj.$key
        if (![string]::IsNullOrEmpty($value))
        {
            Write-LogFile ([string]::Format('Set application {0} property "{1}": {2}', $pathName, $_.Value, $value)) 2
            if ($Script:NoPreview)
            {
                $splat.Add($_.Value, (ConvertTo-Bool $value))
            }
        }
    }
    if ($splat.Count -gt 0)
    {
        Write-LogFile ([string]::Format('Set-BrokerApplication -InputObject $appObj @splat')) 2
        if ($Script:NoPreview)
        {
            Set-BrokerApplication -InputObject $appObj @splat
        }
    }

    if ([string]::IsNullOrEmpty($xmlObj.IconFileName) -and [string]::IsNullOrEmpty($xmlObj.IconData))
    {
        Write-LogFile ([string]::Format('No icon specified for application "{0}", default icon used', $pathName)) 1
    }
    elseif (![string]::IsNullOrEmpty($xmlObj.IconData))
    {
        if ($Script:NoPreview)
        {
            $iconData = New-BrokerIcon -EncodedIconData $xmlObj.IconData
            Write-LogFile ([string]::Format("Application {0} icon created, icon UID is {1}", $pathName, $iconData.Uid)) 1
            $log = [string]::Format('Set-BrokerApplication -InputObject $appObj -IconUid {0}', $iconData.Uid)
            Write-LogFile ($log) 2
            [void](Set-BrokerApplication -InputObject $appObj -IconUid $iconData.Uid)
        }
        else
        {
            Write-LogFile ([string]::Format('Set-BrokerApplication -InputObject $appObj -IconUid <new icon id>')) 2
        }
    }
    elseif (![string]::IsNullOrEmpty($xmlObj.IconFileName))
    {
        $iconFile = Join-Path $iconDir $xmlObj.IconFileName
        if (Test-Path $iconFile)
        {
            Write-LogFile ("Set application icon") 2
            $log = [string]::Format('New-BrokerIcon -EncodedIconData (Get-Content "{0}")', $iconFile)
            Write-LogFile ($log) 3
            if ($Script:NoPreview)
            {
                $iconData = New-BrokerIcon -EncodedIconData (Get-Content $iconFile)
                Write-LogFile ([string]::Format("Application {0} icon created, icon UID is {1}", $pathName, $iconData.Uid)) 1
                $log = [string]::Format('Set-BrokerApplication -InputObject $appObj -IconUid {0}', $iconData.Uid)
                Write-LogFile ($log) 2
                [void](Set-BrokerApplication -InputObject $appObj -IconUid $iconData.Uid)
            }
            else
            {
                Write-LogFile ([string]::Format('Set-BrokerApplication -InputObject $appObj -IconUid <new icon id>')) 2
            }
        }
        else
        {
            $log = [string]::Format('Icon file "{0}" not found, default icon used for application "{1}"', $iconFile, $pathName)
            Write-LogFile ($log) 2
        }
    }

    if ($xmlObj.FileTypes -ne $null)
    {
        Write-LogFile ([string]::Format('Configuring file types for application "{0}"', $pathName)) 1
        $xmlObj.FileTypes.FileType | % {
            if ($_.Extensions -ne $null)
            {
                foreach ($ext in $_.Extensions.Extension)
                {
                    if (!(IsNullOrWhiteSpace $ext))
                    {
                        $log = [string]::Format("Get-BrokerImportedFTA -ExtensionName {0} -DesktopGroupUid {1} -ErrorAction SilentlyContinue",
                            $ext, $Script:DeliveryGroupUid)
                        Write-LogFile ($log) 2
                        $fta = Get-BrokerImportedFTA -ExtensionName $ext -DesktopGroupUid $Script:DeliveryGroupUid -ErrorAction SilentlyContinue
                        if ($fta -ne $null)
                        {
                            Write-LogFile ([string]::Format('Adding file type {0} to application "{1}"', $ext, $pathName)) 2
                            $log = [string]::Format('New-BrokerConfiguredFTA -ApplicationUid "{0}" -ImportedFTA {1}',
                                $appObj.Uid, $fta)
                            Write-LogFile ($log) 3
                            if ($Script:NoPreview)
                            {
                                [void](New-BrokerConfiguredFTA -ApplicationUid $appObj.Uid -ImportedFTA $fta)
                            }
                        }
                        else
                        {
                            Write-LogFile ([string]::Format("File type extension {0} does not exist, ignored", $ext)) 2
                        }
                    }
                }
            }
        }
    }

    if (($xmlObj.Accounts -ne $null) -and ($xmlObj.Accounts.Account -ne $null))
    {
        if ($xmlObj.Accounts.Account -is [System.Object[]])
        {
            $xmlObj.Accounts.Account | % { Add-UserAccount $_.AccountDisplayName $appObj }
        }
        else
        {
            Add-UserAccount $xmlObj.Accounts.Account.AccountDisplayName $appObj
        }
    }
    else
    {
        $log = [string]::Format('INFO: "{0}" has no user accounts defined', $displayName)
        Write-LogFile $log 1 $false
    }

    if (($xmlObj.WorkerGroups -ne $null) -and ($xmlObj.WorkerGroups.WorkerGroup.Count -gt 0))
    {
        $log = [string]::Format('INFO: "{0}" is published to worker groups, which are not imported', $displayName)
        Write-LogFile $log 1 $false
    }

    $Script:AppsImported++
}

<#
    .Synopsis
        Convert to bool if applicable. Otherwise just return the string.
#>

function ConvertTo-Bool
{
    param
    (
        [string] $var
    )

    if ($var.ToUpper() -eq "TRUE")
    {
        return $true
    }
    elseif ($var.ToUpper() -eq "FALSE")
    {
        return $false
    }
    else
    {
        return $var
    }
}

# SIG # Begin signature block
# MIIYFQYJKoZIhvcNAQcCoIIYBjCCGAICAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQUGi36fogE91/C7C5b3gq0oN93
# 8dKgghMjMIID7jCCA1egAwIBAgIQfpPr+3zGTlnqS5p31Ab8OzANBgkqhkiG9w0B
# AQUFADCBizELMAkGA1UEBhMCWkExFTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTEUMBIG
# A1UEBxMLRHVyYmFudmlsbGUxDzANBgNVBAoTBlRoYXd0ZTEdMBsGA1UECxMUVGhh
# d3RlIENlcnRpZmljYXRpb24xHzAdBgNVBAMTFlRoYXd0ZSBUaW1lc3RhbXBpbmcg
# Q0EwHhcNMTIxMjIxMDAwMDAwWhcNMjAxMjMwMjM1OTU5WjBeMQswCQYDVQQGEwJV
# UzEdMBsGA1UEChMUU3ltYW50ZWMgQ29ycG9yYXRpb24xMDAuBgNVBAMTJ1N5bWFu
# dGVjIFRpbWUgU3RhbXBpbmcgU2VydmljZXMgQ0EgLSBHMjCCASIwDQYJKoZIhvcN
# AQEBBQADggEPADCCAQoCggEBALGss0lUS5ccEgrYJXmRIlcqb9y4JsRDc2vCvy5Q
# WvsUwnaOQwElQ7Sh4kX06Ld7w3TMIte0lAAC903tv7S3RCRrzV9FO9FEzkMScxeC
# i2m0K8uZHqxyGyZNcR+xMd37UWECU6aq9UksBXhFpS+JzueZ5/6M4lc/PcaS3Er4
# ezPkeQr78HWIQZz/xQNRmarXbJ+TaYdlKYOFwmAUxMjJOxTawIHwHw103pIiq8r3
# +3R8J+b3Sht/p8OeLa6K6qbmqicWfWH3mHERvOJQoUvlXfrlDqcsn6plINPYlujI
# fKVOSET/GeJEB5IL12iEgF1qeGRFzWBGflTBE3zFefHJwXECAwEAAaOB+jCB9zAd
# BgNVHQ4EFgQUX5r1blzMzHSa1N197z/b7EyALt0wMgYIKwYBBQUHAQEEJjAkMCIG
# CCsGAQUFBzABhhZodHRwOi8vb2NzcC50aGF3dGUuY29tMBIGA1UdEwEB/wQIMAYB
# Af8CAQAwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC50aGF3dGUuY29tL1Ro
# YXd0ZVRpbWVzdGFtcGluZ0NBLmNybDATBgNVHSUEDDAKBggrBgEFBQcDCDAOBgNV
# HQ8BAf8EBAMCAQYwKAYDVR0RBCEwH6QdMBsxGTAXBgNVBAMTEFRpbWVTdGFtcC0y
# MDQ4LTEwDQYJKoZIhvcNAQEFBQADgYEAAwmbj3nvf1kwqu9otfrjCR27T4IGXTdf
# plKfFo3qHJIJRG71betYfDDo+WmNI3MLEm9Hqa45EfgqsZuwGsOO61mWAK3ODE2y
# 0DGmCFwqevzieh1XTKhlGOl5QGIllm7HxzdqgyEIjkHq3dlXPx13SYcqFgZepjhq
# IhKjURmDfrYwggSjMIIDi6ADAgECAhAOz/Q4yP6/NW4E2GqYGxpQMA0GCSqGSIb3
# DQEBBQUAMF4xCzAJBgNVBAYTAlVTMR0wGwYDVQQKExRTeW1hbnRlYyBDb3Jwb3Jh
# dGlvbjEwMC4GA1UEAxMnU3ltYW50ZWMgVGltZSBTdGFtcGluZyBTZXJ2aWNlcyBD
# QSAtIEcyMB4XDTEyMTAxODAwMDAwMFoXDTIwMTIyOTIzNTk1OVowYjELMAkGA1UE
# BhMCVVMxHTAbBgNVBAoTFFN5bWFudGVjIENvcnBvcmF0aW9uMTQwMgYDVQQDEytT
# eW1hbnRlYyBUaW1lIFN0YW1waW5nIFNlcnZpY2VzIFNpZ25lciAtIEc0MIIBIjAN
# BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAomMLOUS4uyOnREm7Dv+h8GEKU5Ow
# mNutLA9KxW7/hjxTVQ8VzgQ/K/2plpbZvmF5C1vJTIZ25eBDSyKV7sIrQ8Gf2Gi0
# jkBP7oU4uRHFI/JkWPAVMm9OV6GuiKQC1yoezUvh3WPVF4kyW7BemVqonShQDhfu
# ltthO0VRHc8SVguSR/yrrvZmPUescHLnkudfzRC5xINklBm9JYDh6NIipdC6Anqh
# d5NbZcPuF3S8QYYq3AhMjJKMkS2ed0QfaNaodHfbDlsyi1aLM73ZY8hJnTrFxeoz
# C9Lxoxv0i77Zs1eLO94Ep3oisiSuLsdwxb5OgyYI+wu9qU+ZCOEQKHKqzQIDAQAB
# o4IBVzCCAVMwDAYDVR0TAQH/BAIwADAWBgNVHSUBAf8EDDAKBggrBgEFBQcDCDAO
# BgNVHQ8BAf8EBAMCB4AwcwYIKwYBBQUHAQEEZzBlMCoGCCsGAQUFBzABhh5odHRw
# Oi8vdHMtb2NzcC53cy5zeW1hbnRlYy5jb20wNwYIKwYBBQUHMAKGK2h0dHA6Ly90
# cy1haWEud3Muc3ltYW50ZWMuY29tL3Rzcy1jYS1nMi5jZXIwPAYDVR0fBDUwMzAx
# oC+gLYYraHR0cDovL3RzLWNybC53cy5zeW1hbnRlYy5jb20vdHNzLWNhLWcyLmNy
# bDAoBgNVHREEITAfpB0wGzEZMBcGA1UEAxMQVGltZVN0YW1wLTIwNDgtMjAdBgNV
# HQ4EFgQURsZpow5KFB7VTNpSYxc/Xja8DeYwHwYDVR0jBBgwFoAUX5r1blzMzHSa
# 1N197z/b7EyALt0wDQYJKoZIhvcNAQEFBQADggEBAHg7tJEqAEzwj2IwN3ijhCcH
# bxiy3iXcoNSUA6qGTiWfmkADHN3O43nLIWgG2rYytG2/9CwmYzPkSWRtDebDZw73
# BaQ1bHyJFsbpst+y6d0gxnEPzZV03LZc3r03H0N45ni1zSgEIKOq8UvEiCmRDoDR
# EfzdXHZuT14ORUZBbg2w6jiasTraCXEQ/Bx5tIB7rGn0/Zy2DBYr8X9bCT2bW+IW
# yhOBbQAuOA2oKY8s4bL0WqkBrxWcLC9JG9siu8P+eJRRw4axgohd8D20UaF5Mysu
# e7ncIAkTcetqGVvP6KUwVyyJST+5z3/Jvz4iaGNTmr1pdKzFHTx/kuDDvBzYBHUw
# ggUwMIIEGKADAgECAhAECRgbX9W7ZnVTQ7VvlVAIMA0GCSqGSIb3DQEBCwUAMGUx
# CzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3
# dy5kaWdpY2VydC5jb20xJDAiBgNVBAMTG0RpZ2lDZXJ0IEFzc3VyZWQgSUQgUm9v
# dCBDQTAeFw0xMzEwMjIxMjAwMDBaFw0yODEwMjIxMjAwMDBaMHIxCzAJBgNVBAYT
# AlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2Vy
# dC5jb20xMTAvBgNVBAMTKERpZ2lDZXJ0IFNIQTIgQXNzdXJlZCBJRCBDb2RlIFNp
# Z25pbmcgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQD407Mcfw4R
# r2d3B9MLMUkZz9D7RZmxOttE9X/lqJ3bMtdx6nadBS63j/qSQ8Cl+YnUNxnXtqrw
# nIal2CWsDnkoOn7p0WfTxvspJ8fTeyOU5JEjlpB3gvmhhCNmElQzUHSxKCa7JGnC
# wlLyFGeKiUXULaGj6YgsIJWuHEqHCN8M9eJNYBi+qsSyrnAxZjNxPqxwoqvOf+l8
# y5Kh5TsxHM/q8grkV7tKtel05iv+bMt+dDk2DZDv5LVOpKnqagqrhPOsZ061xPeM
# 0SAlI+sIZD5SlsHyDxL0xY4PwaLoLFH3c7y9hbFig3NBggfkOItqcyDQD2RzPJ6f
# pjOp/RnfJZPRAgMBAAGjggHNMIIByTASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1Ud
# DwEB/wQEAwIBhjATBgNVHSUEDDAKBggrBgEFBQcDAzB5BggrBgEFBQcBAQRtMGsw
# JAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBDBggrBgEFBQcw
# AoY3aHR0cDovL2NhY2VydHMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElE
# Um9vdENBLmNydDCBgQYDVR0fBHoweDA6oDigNoY0aHR0cDovL2NybDQuZGlnaWNl
# cnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENBLmNybDA6oDigNoY0aHR0cDov
# L2NybDMuZGlnaWNlcnQuY29tL0RpZ2lDZXJ0QXNzdXJlZElEUm9vdENBLmNybDBP
# BgNVHSAESDBGMDgGCmCGSAGG/WwAAgQwKjAoBggrBgEFBQcCARYcaHR0cHM6Ly93
# d3cuZGlnaWNlcnQuY29tL0NQUzAKBghghkgBhv1sAzAdBgNVHQ4EFgQUWsS5eyoK
# o6XqcQPAYPkt9mV1DlgwHwYDVR0jBBgwFoAUReuir/SSy4IxLVGLp6chnfNtyA8w
# DQYJKoZIhvcNAQELBQADggEBAD7sDVoks/Mi0RXILHwlKXaoHV0cLToaxO8wYdd+
# C2D9wz0PxK+L/e8q3yBVN7Dh9tGSdQ9RtG6ljlriXiSBThCk7j9xjmMOE0ut119E
# efM2FAaK95xGTlz/kLEbBw6RFfu6r7VRwo0kriTGxycqoSkoGjpxKAI8LpGjwCUR
# 4pwUR6F6aGivm6dcIFzZcbEMj7uo+MUSaJ/PQMtARKUT8OZkDCUIQjKyNookAv4v
# cn4c10lFluhZHen6dGRrsutmQ9qzsIzV6Q3d9gEgzpkxYz0IGhizgZtPxpMQBvwH
# gfqL2vmCSfdibqFT+hKUGIUukpHqaGxEMrJmoecYpJpkUe8wggVSMIIEOqADAgEC
# AhAHqUmHhtlA7gQpb7ywpEENMA0GCSqGSIb3DQEBCwUAMHIxCzAJBgNVBAYTAlVT
# MRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5j
# b20xMTAvBgNVBAMTKERpZ2lDZXJ0IFNIQTIgQXNzdXJlZCBJRCBDb2RlIFNpZ25p
# bmcgQ0EwHhcNMTcxMDA0MDAwMDAwWhcNMTgxMDExMTIwMDAwWjCBjjELMAkGA1UE
# BhMCVVMxCzAJBgNVBAgTAkZMMRcwFQYDVQQHEw5GdC4gTGF1ZGVyZGFsZTEdMBsG
# A1UEChMUQ2l0cml4IFN5c3RlbXMsIEluYy4xGzAZBgNVBAsTElhlbkFwcChwb3dl
# cnNoZWxsKTEdMBsGA1UEAxMUQ2l0cml4IFN5c3RlbXMsIEluYy4wggEiMA0GCSqG
# SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDpOw/kqgT7XlrBj0BLHk2PqVq3oIKAt+3P
# f0oR369Dwulm6txEeA3XwvCaie7218lZwIu6iBHyCEH+E0J3Yd1GUMjzq5K3EGza
# HdPycKYwENwZ6O9RkPpoxcWyEyJ31fUKQ/GY73pe/nyLpQ8RvObk+AvYwvk9ugvm
# Yam2fd56vC0Lk4BZSZGJ8ldN2AqQjHGdXeo7B1m676jTIZHXke7IuDo8u7HBlYB2
# xvjUUmIHKr//3tG4F5o2qIKBI0lmbEukp0HoSP/CSiHTntQMyPvAniAY6bz1mlyR
# SL4CuBHKyK98zxRQ+CCkOiqerPSyRN86VI2yjNIgJgSQXZTNp48XAgMBAAGjggHF
# MIIBwTAfBgNVHSMEGDAWgBRaxLl7KgqjpepxA8Bg+S32ZXUOWDAdBgNVHQ4EFgQU
# vfnx+wp/tJ3YnKOGlCI4+nU/7KswDgYDVR0PAQH/BAQDAgeAMBMGA1UdJQQMMAoG
# CCsGAQUFBwMDMHcGA1UdHwRwMG4wNaAzoDGGL2h0dHA6Ly9jcmwzLmRpZ2ljZXJ0
# LmNvbS9zaGEyLWFzc3VyZWQtY3MtZzEuY3JsMDWgM6Axhi9odHRwOi8vY3JsNC5k
# aWdpY2VydC5jb20vc2hhMi1hc3N1cmVkLWNzLWcxLmNybDBMBgNVHSAERTBDMDcG
# CWCGSAGG/WwDATAqMCgGCCsGAQUFBwIBFhxodHRwczovL3d3dy5kaWdpY2VydC5j
# b20vQ1BTMAgGBmeBDAEEATCBhAYIKwYBBQUHAQEEeDB2MCQGCCsGAQUFBzABhhho
# dHRwOi8vb2NzcC5kaWdpY2VydC5jb20wTgYIKwYBBQUHMAKGQmh0dHA6Ly9jYWNl
# cnRzLmRpZ2ljZXJ0LmNvbS9EaWdpQ2VydFNIQTJBc3N1cmVkSURDb2RlU2lnbmlu
# Z0NBLmNydDAMBgNVHRMBAf8EAjAAMA0GCSqGSIb3DQEBCwUAA4IBAQBU0zauN2qh
# o+NFxYu+cTDfdUBI7gTdPL2eOzMcv2Wg21IqxjObnszSgBjIgq8vcdKy3UajF9qW
# 0GcI6KaSjSrIKXWih3fuhPF/B/DGBWXFmruoLlL3syUpUZZCQGMRYoXqagCuv+ve
# BwZIYXzr2dWK0P8/9CJj6XOEFiE4Aik1PgSuSwYvnLGscnb7GFbQTxyoTrGn9MzX
# EoSkB4i6a7oRcDczNQ5CxrzHYPL9nyOr0RKzvlwzg0W8f6To00UPTI49SEyp+Psi
# GuDJSE58l2O1qzZH2a8bvEYbFNhoCbx+TWAmJShKe4zJeZc5G9rdXxJhEtKVUbCe
# 1kaofEyg/JP5MYIEXDCCBFgCAQEwgYYwcjELMAkGA1UEBhMCVVMxFTATBgNVBAoT
# DERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTExMC8GA1UE
# AxMoRGlnaUNlcnQgU0hBMiBBc3N1cmVkIElEIENvZGUgU2lnbmluZyBDQQIQB6lJ
# h4bZQO4EKW+8sKRBDTAJBgUrDgMCGgUAoIGcMBkGCSqGSIb3DQEJAzEMBgorBgEE
# AYI3AgEEMBwGCisGAQQBgjcCAQsxDjAMBgorBgEEAYI3AgEVMCMGCSqGSIb3DQEJ
# BDEWBBQcxysQYKreCaRB336wOjEc5Yex+DA8BgorBgEEAYI3AgEMMS4wLKAYgBYA
# QwBpAHQAcgBpAHgAIABGAGkAbABloRCADnd3dy5jaXRyaXguY29tMA0GCSqGSIb3
# DQEBAQUABIIBAJ83NaKnwqcLymrMe4+oCp3hXXfH8Bxd8hm9lQcZ4CemH/Cso9jW
# Hbb12jYW7p6lvrltXDRx4Fl0OJc1wqSiA01tRSB8m3Q+qpfqFUe9K60GTW4fr2yA
# eGretQdG/f4NyBOfU/9IiDRLBBztYIdksoH4UvATccfGx1cgFgkHdJek6R++s1lr
# XyPVfFEa7/Z+rnc5cAA0M3z4ZIqCeUTZpBXeV90TEzjk8QFfyHtwbgU07qmwor1a
# Ht5upI6sDhXU/KNrF0cV2lcaWz3lfwNOZaabp0c4Ec3tp+itR3zCrPxKb3CmNXX+
# H6p/zKP8GaLveADjrQ2IdQCqPqxYp56x472hggILMIICBwYJKoZIhvcNAQkGMYIB
# +DCCAfQCAQEwcjBeMQswCQYDVQQGEwJVUzEdMBsGA1UEChMUU3ltYW50ZWMgQ29y
# cG9yYXRpb24xMDAuBgNVBAMTJ1N5bWFudGVjIFRpbWUgU3RhbXBpbmcgU2Vydmlj
# ZXMgQ0EgLSBHMgIQDs/0OMj+vzVuBNhqmBsaUDAJBgUrDgMCGgUAoF0wGAYJKoZI
# hvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTcxMTA4MTk0MTUy
# WjAjBgkqhkiG9w0BCQQxFgQU0lFYu/jCHSNTtvQiWgiDBaQejrAwDQYJKoZIhvcN
# AQEBBQAEggEAeMWpsn0jyP52T63j/0wIFUN+RrAVYyUA0ptS9o5+jvbDph6f7Jz7
# o3L+eaYeXNQdIjehBSVbSeK3kWnu5fRwgbYsSsPYysSTGXcNtkSOX83BM/k034SQ
# OV0bHbA13/ZCZTK4xjhNqcYF16QAb1gqiIzhQoU+RERoyn+WqV2cYmU3WOfsE0L2
# 8lMEkoFULQXpccYVf7KnLQ5e/sis85yfSvzOuK+lVRpKZ9reGUKOpqu2jvXCfIT9
# cKLWmgq6YkdqxQOQ+03kxTDYKkGFNdpB4FyiIHO9XD+ohX7iHMNATJLuEe9he+O2
# o6RM+xIRRTAs6XNItFO0jTtOtZDTByvEzw==
# SIG # End signature block
